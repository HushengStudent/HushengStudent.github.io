---
layout: post
title:  "[数据结构]队列"
date:   2015-06-12 23:45:10
categories: 37---【数据结构与算法】#####
comments: true
---

①队列的定义及实现：

队列是一种特殊的线性表、队列仅在线性表的两端进行操作。

队头(Front)：取出数据元素的一端。

队尾(Rear)：插入数据元素的一端。

队列不允许在中间部位进行操作。

性质：先进先出(FIFO)

队列的一些常用操作:创建队列、销毁队列、清空队列、进队列、出队列、获取队头元素、获取队列的长度。

Queue.h：
```java
#ifndef Queue_H  
#define Queue_H  
  
typedef int Item;  
typedef struct node * PNode;  
typedef struct node  
{  
    Item data;  
    PNode next;  
}Node;  
  
typedef struct  
{  
    PNode front;  
    PNode rear;  
    int size;  
}Queue;  
  
Queue *InitQueue();  
  
void DestroyQueue(Queue *pqueue);  
  
void ClearQueue(Queue *pqueue);  
  
int IsEmpty(Queue *pqueue);  
  
int GetSize(Queue *pqueue);  
  
PNode GetFront(Queue *pqueue,Item *pitem);  
  
PNode GetRear(Queue *pqueue,Item *pitem);  
  
PNode EnQueue(Queue *pqueue,Item item);  
  
PNode DeQueue(Queue *pqueue,Item *pitem);  
  
void QueueTraverse(Queue *pqueue,void (*visit)());  
  
#endif  
```
Queue.c：
```java
#include"Queue.h"  
#include<malloc.h>  
#include<stdio.h>  
  
Queue *InitQueue()  
{  
    Queue *pqueue = (Queue *)malloc(sizeof(Queue));  
    if(pqueue!=NULL)  
    {  
        pqueue->front = NULL;  
        pqueue->rear = NULL;  
        pqueue->size = 0;  
    }  
    return pqueue;  
}  
  
void DestroyQueue(Queue *pqueue)  
{  
    if(IsEmpty(pqueue)!=1)  
        ClearQueue(pqueue);  
    free(pqueue);  
}  
  
void ClearQueue(Queue *pqueue)  
{  
    while(IsEmpty(pqueue)!=1)  
    {  
        DeQueue(pqueue,NULL);  
    }  
  
}  
  
int IsEmpty(Queue *pqueue)  
{  
    if(pqueue->front==NULL&&pqueue->rear==NULL&&pqueue->size==0)  
        return 1;  
    else  
        return 0;  
}  
  
int GetSize(Queue *pqueue)  
{  
    return pqueue->size;  
}  
  
PNode GetFront(Queue *pqueue,Item *pitem)  
{  
    if(IsEmpty(pqueue)!=1&&pitem!=NULL)  
    {  
        *pitem = pqueue->front->data;  
    }  
    return pqueue->front;  
}  
  
PNode GetRear(Queue *pqueue,Item *pitem)  
{  
    if(IsEmpty(pqueue)!=1&&pitem!=NULL)  
    {  
        *pitem = pqueue->rear->data;  
    }  
    return pqueue->rear;  
}  
  
PNode EnQueue(Queue *pqueue,Item item)  
{  
    PNode pnode = (PNode)malloc(sizeof(Node));  
    if(pnode != NULL)  
    {  
        pnode->data = item;  
        pnode->next = NULL;  
          
        if(IsEmpty(pqueue))  
        {  
            pqueue->front = pnode;  
        }  
        else  
        {  
            pqueue->rear->next = pnode;  
        }  
        pqueue->rear = pnode;  
        pqueue->size++;  
    }  
    return pnode;  
}  
  
PNode DeQueue(Queue *pqueue,Item *pitem)  
{  
    PNode pnode = pqueue->front;  
    if(IsEmpty(pqueue)!=1&&pnode!=NULL)  
    {  
        if(pitem!=NULL)  
            *pitem = pnode->data;  
        pqueue->size--;  
        pqueue->front = pnode->next;  
        free(pnode);  
        if(pqueue->size==0)  
            pqueue->rear = NULL;  
    }  
    return pqueue->front;  
}  
  
void QueueTraverse(Queue *pqueue,void (*visit)())  
{  
    PNode pnode = pqueue->front;  
    int i = pqueue->size;  
    while(i--)  
    {  
        visit(pnode->data);  
        pnode = pnode->next;  
    }  
          
}  
```
Test.c：

```java
#include"Queue.h"  
#include<stdio.h>  
  
void print(Item i)  
{  
    printf("该节点元素为%d\n",i);  
}  
  
main()  
{  
    Queue *pq = InitQueue();  
    int i,item;  
    printf("0-9依次入队并输出如下：\n");  
    for(i=0;i<10;i++)  
    {  
        EnQueue(pq,i);  
        GetRear(pq,&item);  
        printf("%d ",item);  
    }  
  
    printf("\n从队头到队尾遍历并对每个元素执行print函数：\n");   
    QueueTraverse(pq,print);  
  
    printf("队列中元素依次出队列并输出如下：\n");  
    for(i=0;i<10;i++)  
    {  
        DeQueue(pq,&item);  
        printf("%d ",item);  
    }  
    ClearQueue(pq);  
    if(IsEmpty(pq))  
        printf("\n将队列置空成功\n");  
    DestroyQueue(pq);  
    printf("队列已被销毁\n");  
}  
```