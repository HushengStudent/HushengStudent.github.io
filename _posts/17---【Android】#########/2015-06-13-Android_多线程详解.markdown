---
layout: post
title:  "[Android]Android_多线程详解"
date:   2015-06-13 12:59:10
categories: 17---【Android】#########
comments: true
---

### 一、线程的基本用法：
#### ①继承Thread：
```java
class MyThread extends Thread{  
    public void run(){  
        //处理逻辑  
    }  
}  
```
启动该线程：
```java
new MyThread().start();  
```
#### ②实现Runnable接口：
```java
class MyThread implements Runnable{  
    public void run(){  
        //处理逻辑  
    }  
}  
```
启动该线程：
```java
MyThread myThread = new MyThread();  
new Thread(myThread).start();  
```
也可直接把Runnable当成内部类使用：
```java
new Thread(new Runnable(){  
public void run(){  
//逻辑  
}  
}).start();  
```
### 二、Handler消息传递机制：
#### ①简介：
![图片](http://owk5gjdrg.bkt.clouddn.com/0023Android_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3.png)
Handler类的主要作用：

1、在新启动的线程中发送消息。

2、在主线程中获取、处理消息。

主要方法：

1、void handleMessage(Message msg)：处理消息方法。

2、final boolean hasMessa(int what)：检查消息队列中是否包含what属性为指定值的消息。

3、final boolean hasMessa(int what,Object object)：检查消息队列中是否包含what属性为指定值且object属性为指定对象的消息。

4、多个重载Message obtainMessage()：获取消息。

5、sendEmptyMessage(int what)：发送空消息。

6、final boolean sendEmptymessage(int what,long delayMillis)：指定多少毫秒后发送空消息。

7、final boolean sendMessage(Message msg)：立即发送消息。

8、final boolean sendMessageDelayed(Messsage msg,long delayMillis)：指定多少毫秒后发送消息。

#### ②实例：
```java
public class MainActivity extends Activity implements OnClickListener {  
  
    public static final int UPDATE_TEXT = 1;  
    private TextView text;  
    private Button changeText;  
    private Handler handler = new Handler() {  
        public void handleMessage(Message msg) {  
            switch (msg.what) {  
            case UPDATE_TEXT:  
                text.setText("Nice to meet you");  
                break;  
            default:  
                break;  
            }  
        }  
    };  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        text = (TextView) findViewById(R.id.text);  
        changeText = (Button) findViewById(R.id.change_text);  
        changeText.setOnClickListener(this);  
    }  
  
    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.change_text:  
            new Thread(new Runnable() {  
                @Override  
                public void run() {  
                    Message message = new Message();  
                    message.what = UPDATE_TEXT;  
                    handler.sendMessage(message);  
                }  
            }).start();  
            break;  
        default:  
            break;  
        }  
    }  
}  
```
#### ③Handler、Loop、MessageQueue的工作原理：
1、Message：Handler接收和处理的消息对象。

2、Looper：每个线程只能拥有一个Looper。它的loop方法负责读取MessageQueue中的消息，读到信息后就把消息交给发送该消息的Handler进行处理。

3、MessageQueue：消息队列，以先进先出方式管理Nessage。

程序在初始化Looper时，会创建一个与之关联的MessageQueue负责管理消息：Handler：发送和处理消息。

### 三、AsyncTask异步任务：
#### ①简介：
![图片](http://owk5gjdrg.bkt.clouddn.com/0024Android_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3.png)
Params：启动任务执行的输入参数类型。

Progress：后台任务完成的进度值的类型。

Result：后台任务执行完成后返回结果的类型。

#### ②实例：
```java
public class AsyncTaskTest extends Activity  
{  
    private TextView show;  
  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        show = (TextView) findViewById(R.id.show);  
    }  
  
    public void download(View source) throws MalformedURLException  
    {  
        DownTask task = new DownTask(this);  
        task.execute(new URL("http://a2.att.hudong.com/04/58/300001054794129041580438110_950.jpg"));  
    }  
  
    class DownTask extends AsyncTask<URL, Integer, String>  
    {  
        ProgressDialog pdialog;  
        // 定义记录已经读取行的数量  
        int hasRead = 0;  
        Context mContext;  
        public DownTask(Context ctx)  
        {  
            mContext = ctx;  
        }  
  
        @Override  
        protected String doInBackground(URL... params)  
        {  
            StringBuilder sb = new StringBuilder();  
            try  
            {  
                URLConnection conn = params[0].openConnection();  
                BufferedReader br = new BufferedReader(  
                    new InputStreamReader(conn.getInputStream()  
                    , "utf-8"));  
                String line = null;  
                while ((line = br.readLine()) != null)  
                {  
                    sb.append(line + "\n");  
                    hasRead++;  
                    publishProgress(hasRead);  
                }  
                return sb.toString();  
            }  
            catch (Exception e)  
            {  
                e.printStackTrace();  
            }  
            return null;  
        }  
  
        @Override  
        protected void onPostExecute(String result)  
        {  
            show.setText(result);  
            pdialog.dismiss();  
        }  
  
        @Override  
        protected void onPreExecute()  
        {  
            pdialog = new ProgressDialog(mContext);  
            // 设置对话框的标题  
            pdialog.setTitle("任务正在执行中");  
            // 设置对话框 显示的内容  
            pdialog.setMessage("任务正在执行中，敬请等待...");  
            // 设置对话框不能用“取消”按钮关闭  
            pdialog.setCancelable(false);  
            // 设置该进度条的最大进度值  
            pdialog.setMax(202);  
            // 设置对话框的进度条风格  
            pdialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);  
            // 设置对话框的进度条是否显示进度  
            pdialog.setIndeterminate(false);  
            pdialog.show();  
        }  
  
        @Override  
        protected void onProgressUpdate(Integer... values)  
        {  
            // 更新进度  
            show.setText("已经读取了【" + values[0] + "】行！");  
            pdialog.setProgress(values[0]);  
        }  
    }  
}  
```
### 四、总结：
掌握Handler、AsyncTask的用法，反复练习。